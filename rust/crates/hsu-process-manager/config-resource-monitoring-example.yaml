# Process Manager Configuration - Resource Monitoring & Limits
# This example demonstrates resource usage monitoring and limit enforcement

process_manager:
  port: 50055
  log_level: "info"
  force_shutdown_timeout: "30s"

managed_processes:
  # ========================================
  # Example 1: Memory-Limited Service
  # ========================================
  - id: "cache-server"
    type: "standard_managed"
    enabled: true
    management:
      control:
        executable: "/usr/local/bin/redis-server"
        arguments: ["--port", "6379"]
        startup_timeout: "5s"
        shutdown_timeout: "5s"
      
      # Resource limits
      resource_limits:
        max_memory_mb: 512          # Limit to 512 MB
        max_cpu_percent: null       # No CPU limit
        max_file_descriptors: null  # No FD limit
      
      # Health check (optional)
      health_check:
        enabled: true
        interval: "30s"
        timeout: "3s"
        failure_threshold: 3
        http_endpoint: "http://localhost:6379/ping"
      
      # Restart policy
      restart_policy:
        strategy: "always"
        max_attempts: 5
        restart_delay: "5s"
        backoff_multiplier: 2.0
      
      # BEHAVIOR:
      # - Resource usage monitored every 10 seconds
      # - If memory > 512 MB: violation logged
      # - ProcessInfo shows current CPU/memory usage
      # - TODO: Trigger restart on violation

  # ========================================
  # Example 2: CPU-Limited Process
  # ========================================
  - id: "background-worker"
    type: "standard_managed"
    enabled: true
    management:
      control:
        executable: "/usr/local/bin/worker"
        arguments: ["--threads", "4"]
        startup_timeout: "10s"
        shutdown_timeout: "10s"
      
      resource_limits:
        max_memory_mb: null          # No memory limit
        max_cpu_percent: 50.0        # Limit to 50% CPU
        max_file_descriptors: null   # No FD limit
      
      restart_policy:
        strategy: "on_failure"
        max_attempts: 3
        restart_delay: "10s"
        backoff_multiplier: 2.0
      
      # BEHAVIOR:
      # - Monitor CPU usage every 10s
      # - If CPU > 50%: violation logged
      # - Useful for background tasks that shouldn't hog CPU

  # ========================================
  # Example 3: Comprehensive Limits
  # ========================================
  - id: "web-application"
    type: "standard_managed"
    enabled: true
    management:
      control:
        executable: "/usr/local/bin/webapp"
        arguments: ["--port", "8080"]
        startup_timeout: "15s"
        shutdown_timeout: "10s"
      
      resource_limits:
        max_memory_mb: 1024          # 1 GB memory
        max_cpu_percent: 80.0        # 80% CPU
        max_file_descriptors: 2048   # 2048 open files (Unix only)
      
      health_check:
        enabled: true
        interval: "30s"
        timeout: "5s"
        failure_threshold: 3
        http_endpoint: "http://localhost:8080/health"
      
      restart_policy:
        strategy: "on_failure"
        max_attempts: 3
        restart_delay: "5s"
        backoff_multiplier: 2.0
      
      # BEHAVIOR:
      # - All resources monitored
      # - Multiple limits enforced
      # - Combined with health checks
      # - Production-ready configuration

  # ========================================
  # Example 4: No Limits (Monitoring Only)
  # ========================================
  - id: "database-server"
    type: "standard_managed"
    enabled: true
    management:
      control:
        executable: "/usr/local/bin/postgres"
        arguments: ["-D", "/var/lib/postgres/data"]
        startup_timeout: "30s"
        shutdown_timeout: "15s"
      
      # No resource limits - monitoring only
      resource_limits: null
      
      restart_policy:
        strategy: "on_failure"
        max_attempts: 2
        restart_delay: "30s"
        backoff_multiplier: 3.0
      
      # BEHAVIOR:
      # - Resource usage still monitored and exposed
      # - No limits enforced
      # - Data visible in ProcessInfo
      # - Useful for observability without constraints

  # ========================================
  # Example 5: File Descriptor Limit
  # ========================================
  - id: "file-server"
    type: "standard_managed"
    enabled: true
    management:
      control:
        executable: "/usr/local/bin/fileserver"
        arguments: ["--port", "9000"]
        startup_timeout: "10s"
        shutdown_timeout: "10s"
      
      resource_limits:
        max_memory_mb: null
        max_cpu_percent: null
        max_file_descriptors: 1024   # Limit open files (Unix)
      
      restart_policy:
        strategy: "on_failure"
        max_attempts: 3
        restart_delay: "5s"
        backoff_multiplier: 2.0
      
      # BEHAVIOR:
      # - Monitors file descriptor count
      # - Unix-specific: reads /proc/[pid]/fd
      # - Windows: FD count not available
      # - Useful for services with many connections

# ========================================
# Resource Monitoring Details
# ========================================
#
# **Monitoring Interval:** 10 seconds (hard-coded)
# - Background task per process
# - Collects: CPU%, memory MB, file descriptors
# - Updates ProcessInfo structure
# - Runs until process stops
#
# **CPU Usage:**
# - Percentage of single core (0-100%)
# - Can exceed 100% on multi-core systems
# - Collected via sysinfo library
# - Cross-platform (Linux, macOS, Windows)
#
# **Memory Usage:**
# - RSS (Resident Set Size) in megabytes
# - Actual physical memory used
# - Does not include swap
# - Cross-platform
#
# **File Descriptors:**
# - Unix: Count from /proc/[pid]/fd
# - Windows: Not available
# - Includes: files, sockets, pipes
# - Useful for connection tracking
#
# **Network Connections:**
# - TODO: Not yet implemented
# - Future enhancement
#
# ========================================
# Resource Limit Enforcement
# ========================================
#
# **Limit Checking:**
# - Performed during each monitoring cycle (10s)
# - Compares usage against configured limits
# - Logs violations with error level
# - Multiple violations can occur simultaneously
#
# **Violation Actions:**
# - Currently: Log error message only
# - TODO: Configurable actions:
#   * warn: Log only (current behavior)
#   * restart: Trigger restart policy
#   * kill: Terminate process immediately
#
# **Example Violation Log:**
# ERROR: Resource limit violations for cache-server: Memory usage 600 MB exceeds limit 512 MB
#
# ========================================
# Integration with ProcessInfo
# ========================================
#
# The `ProcessInfo` structure includes:
# ```rust
# pub struct ProcessInfo {
#     pub id: String,
#     pub state: ProcessState,
#     pub pid: Option<u32>,
#     pub cpu_usage: Option<f32>,      // ← From resource monitoring
#     pub memory_usage: Option<u64>,   // ← From resource monitoring
#     pub uptime: Option<Duration>,
#     pub is_healthy: bool,
#     pub last_health_check: Option<DateTime<Utc>>,
#     pub consecutive_health_failures: u32,
#     // ... other fields
# }
# ```
#
# Access via:
# - ProcessManager::get_process_info(id)
# - Future: HTTP API GET /processes/{id}
# - Future: gRPC GetProcessInfo RPC
#
# ========================================
# Cross-Platform Support
# ========================================
#
# **Linux:**
# - CPU: ✅ via sysinfo
# - Memory: ✅ via sysinfo
# - FDs: ✅ via /proc/[pid]/fd
# - Network: ❌ TODO
#
# **macOS:**
# - CPU: ✅ via sysinfo
# - Memory: ✅ via sysinfo
# - FDs: ✅ via /proc (if available)
# - Network: ❌ TODO
#
# **Windows:**
# - CPU: ✅ via sysinfo
# - Memory: ✅ via sysinfo
# - FDs: ❌ Not available
# - Network: ❌ TODO
#
# ========================================
# Best Practices
# ========================================
#
# **Memory Limits:**
# - Set based on expected usage + headroom
# - Too tight: False alarms
# - Too loose: OOM risk
# - Typical web apps: 256-1024 MB
# - Databases: 2048+ MB
# - Microservices: 128-512 MB
#
# **CPU Limits:**
# - Percentage of single core
# - Multi-threaded apps can use >100%
# - Background workers: 50-80%
# - High-priority services: 80-100%
# - Be generous to avoid throttling
#
# **File Descriptor Limits:**
# - Unix-specific metric
# - Includes all open resources
# - Web servers with many connections: 2048+
# - Simple services: 256-1024
# - Monitor for connection leaks
#
# **Monitoring Interval:**
# - Fixed at 10 seconds
# - Good balance between responsiveness and overhead
# - Can be adjusted in code if needed
# - Consider process startup time
#
# ========================================
# Troubleshooting
# ========================================
#
# **High CPU Usage:**
# - Check if limit is realistic
# - Multi-threaded apps use multiple cores
# - Spike during startup is normal
# - Persistent high usage may indicate issue
#
# **High Memory Usage:**
# - Check for memory leaks
# - Consider caching behavior
# - Monitor growth over time
# - Restart may temporarily help
#
# **File Descriptor Exhaustion:**
# - Check for connection leaks
# - Ensure proper resource cleanup
# - Increase limit if legitimate
# - Monitor fd/connection ratio
#
# **No Resource Data:**
# - Check if process is running
# - Verify PID is valid
# - sysinfo may need time to collect
# - Windows: FDs always None
#
# ========================================
# Future Enhancements
# ========================================
#
# **Planned Features:**
# - [ ] Network connection counting
# - [ ] Disk I/O monitoring
# - [ ] Configurable monitoring intervals
# - [ ] Resource usage history/graphs
# - [ ] Automatic actions on violations:
#   * Warn only (current)
#   * Restart process
#   * Kill process
#   * Graceful degradation
# - [ ] Aggregated resource statistics
# - [ ] Resource usage alerts/webhooks
# - [ ] Cgroup integration (Linux)
# - [ ] Resource reservation
#
# **Integration Goals:**
# - Export metrics to Prometheus
# - Send alerts to monitoring systems
# - Automated scaling decisions
# - Capacity planning data

