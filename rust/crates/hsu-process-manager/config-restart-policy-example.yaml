# Process Manager Configuration - Restart Policy Examples
# This example demonstrates the restart policy system with:
# - Three restart strategies (Never, OnFailure, Always)
# - Exponential backoff
# - Max restart attempts
# - Circuit breaker protection

process_manager:
  port: 50055
  log_level: "info"
  force_shutdown_timeout: "30s"

managed_processes:
  # ========================================
  # Restart Strategy: NEVER
  # ========================================
  # Process exits and stays stopped regardless of exit code
  # Use case: One-time tasks, manual intervention required
  - id: "database-migration"
    type: "standard_managed"
    enabled: true
    management:
      control:
        executable: "/usr/local/bin/db-migrate"
        arguments: ["--env", "production"]
        startup_timeout: "30s"
        shutdown_timeout: "10s"
      
      restart_policy:
        strategy: "never"
        # Other parameters ignored for 'never' strategy
        max_attempts: 0
        restart_delay: "0s"
        backoff_multiplier: 1.0
  
  # ========================================
  # Restart Strategy: ON_FAILURE
  # ========================================
  # Process restarts only if it exits with non-zero code
  # Includes exponential backoff and max attempts
  # Use case: Services that should recover from crashes
  - id: "web-api"
    type: "standard_managed"
    enabled: true
    management:
      control:
        executable: "/usr/local/bin/web-server"
        arguments: ["--port", "8080"]
        startup_timeout: "10s"
        shutdown_timeout: "15s"
      
      restart_policy:
        strategy: "on_failure"  # Only restart on crash (exit code != 0)
        max_attempts: 3         # Try up to 3 times
        restart_delay: "5s"     # Base delay between restarts
        backoff_multiplier: 2.0 # Double delay each time
        
      # Restart delays with backoff:
      # Attempt 1: 5s  (base_delay)
      # Attempt 2: 10s (base_delay * 2.0^1)
      # Attempt 3: 20s (base_delay * 2.0^2)
      # After 3 failures: stops trying
  
  # ========================================
  # Restart Strategy: ALWAYS
  # ========================================
  # Process restarts regardless of exit code
  # Use case: Services that must always be running
  - id: "monitoring-agent"
    type: "standard_managed"
    enabled: true
    management:
      control:
        executable: "/usr/local/bin/monitor"
        arguments: ["--interval", "60"]
        startup_timeout: "5s"
        shutdown_timeout: "10s"
      
      restart_policy:
        strategy: "always"      # Restart even on clean exit (exit code 0)
        max_attempts: 5         # Try up to 5 times
        restart_delay: "3s"     # Base delay
        backoff_multiplier: 1.5 # Gentler backoff
        
      # Restart delays with backoff:
      # Attempt 1: 3s   (base_delay)
      # Attempt 2: 4.5s (base_delay * 1.5^1)
      # Attempt 3: 6.75s (base_delay * 1.5^2)
      # Attempt 4: 10.1s (base_delay * 1.5^3)
      # Attempt 5: 15.2s (base_delay * 1.5^4)
      # Maximum delay is capped at 5 minutes (300s)
  
  # ========================================
  # Aggressive Restart Policy
  # ========================================
  # Quick restarts with many attempts
  # Use case: Critical services that need rapid recovery
  - id: "cache-server"
    type: "standard_managed"
    enabled: true
    management:
      control:
        executable: "/usr/local/bin/redis-server"
        arguments: ["--port", "6379"]
        startup_timeout: "5s"
        shutdown_timeout: "5s"
      
      restart_policy:
        strategy: "always"
        max_attempts: 10        # Many attempts
        restart_delay: "1s"     # Fast initial retry
        backoff_multiplier: 1.2 # Slow backoff
  
  # ========================================
  # Conservative Restart Policy
  # ========================================
  # Slow restarts with few attempts
  # Use case: Resource-heavy services
  - id: "data-processor"
    type: "standard_managed"
    enabled: true
    management:
      control:
        executable: "/usr/local/bin/process-data"
        arguments: ["--batch-size", "1000"]
        startup_timeout: "60s"
        shutdown_timeout: "30s"
      
      restart_policy:
        strategy: "on_failure"
        max_attempts: 2         # Few attempts
        restart_delay: "30s"    # Long initial delay
        backoff_multiplier: 3.0 # Aggressive backoff
        
      # Restart delays:
      # Attempt 1: 30s  (30 seconds)
      # Attempt 2: 90s  (1.5 minutes)
      # Then gives up

# ========================================
# Circuit Breaker Protection
# ========================================
#
# The circuit breaker automatically protects against restart loops:
#
# - Threshold: 5 failures within 60 seconds
# - Action: Trips and prevents further restart attempts
# - Cooldown: 5 minutes before allowing retry
# - Reset: Automatic after cooldown, or manual via API
#
# Example scenario:
# 1. Process crashes 5 times in 60 seconds
# 2. Circuit breaker trips
# 3. Log: "Circuit breaker TRIPPED for process: web-api after 5 consecutive failures"
# 4. No more restart attempts for 5 minutes
# 5. After cooldown: Manual intervention or automatic reset
#
# Circuit breaker state:
# - CLOSED: Normal operation, restarts allowed
# - OPEN: Tripped, restarts blocked
# - HALF-OPEN: After cooldown, testing if service recovered
#
# Admin commands (via future API):
# - GET /processes/{id}/circuit-breaker - Check circuit breaker state
# - POST /processes/{id}/circuit-breaker/reset - Manually reset
# - GET /processes/{id}/restart-stats - View restart history

# ========================================
# Restart Statistics
# ========================================
#
# The ProcessLifecycleManager tracks:
# - restart_attempts: Current count of restart attempts
# - last_restart_time: Timestamp of last restart
# - consecutive_failures: Number of failures in a row
# - circuit_breaker.recent_failures: Failure timestamps
# - circuit_breaker.is_tripped: Whether circuit breaker is active
# - circuit_breaker.tripped_at: When it tripped
#
# These statistics can be queried via:
# - ProcessManager::get_process_info()
# - Future monitoring APIs
# - Log messages

# ========================================
# Best Practices
# ========================================
#
# 1. **Never** strategy:
#    - Use for: One-time tasks, migrations, manual processes
#    - Don't use for: Long-running services
#
# 2. **OnFailure** strategy (recommended):
#    - Use for: Most services
#    - Provides recovery from crashes
#    - Respects clean shutdowns
#    - Configure 3-5 max_attempts
#    - Use 2.0 backoff_multiplier
#
# 3. **Always** strategy:
#    - Use for: Critical infrastructure
#    - Warning: Will restart even on clean exit
#    - May hide bugs or configuration issues
#    - Monitor restart frequency
#
# 4. **Backoff configuration**:
#    - Short delays (1-5s) for quick recovery
#    - Medium delays (5-15s) for normal services
#    - Long delays (30s+) for heavy processes
#    - Multiplier 1.5-2.0 for balanced backoff
#    - Multiplier 2.5-3.0 for aggressive backoff
#
# 5. **Max attempts**:
#    - 2-3 attempts: Conservative, avoid loops
#    - 3-5 attempts: Recommended for most services
#    - 5-10 attempts: For critical services
#    - >10 attempts: Risk of restart loops (circuit breaker will help)
#
# 6. **Circuit breaker**:
#    - Automatically protects against restart loops
#    - No configuration needed (built-in)
#    - Monitor for frequent trips (indicates systemic issues)
#    - Reset manually after fixing root cause

